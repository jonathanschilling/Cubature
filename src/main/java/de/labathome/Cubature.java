package de.labathome;

public class Cubature {

	/* error return codes */
	public static final int SUCCESS = 0;
	public static final int FAILURE = 1;

	public static class EstErr {
		public double val, err;
	}

	/**
	 * a vector integrand - evaluates the function at the given point x (an array of
	 * length ndim) and returns the result in fval (an array of length fdim). The
	 * void* parameter is there in case you have to pass any additional data through
	 * to your function (it corresponds to the fdata parameter you pass to
	 * cubature). Return 0 on success or nonzero to terminate the integration.
	 */
	public static interface Integrand {
		public int eval(int ndim, final double[] x, Object fdata, int fdim, double[] fval);
	}

	/**
	 * a vector integrand of a vector of npt points: x[i*ndim + j] is the j-th
	 * coordinate of the i-th point, and the k-th function evaluation for the i-th
	 * point is returned in fval[i*fdim + k]. Return 0 on success or nonzero to
	 * terminate the integration.
	 */
	public static interface Integrand_v {
		public int eval(int ndim, int npt, final double[] x, Object fdata, int fdim, double[] fval);
	}

	/**
	 * Different ways of measuring the absolute and relative error when we have
	 * multiple integrands, given a vector e of error estimates in the individual
	 * components of a vector v of integrands. These are all equivalent when there
	 * is only a single integrand.
	 */
	enum ErrorNorm {
		/** individual relerr criteria in each component */
		ERROR_INDIVIDUAL,

		/**
		 * paired L2 norms of errors in each component, mainly for integrating vectors
		 * of complex numbers
		 */
		ERROR_PAIRED,

		/** abserr is L_2 norm |e|, and relerr is |e|/|v| */
		ERROR_L2,

		/** abserr is L_1 norm |e|, and relerr is |e|/|v| */
		ERROR_L1,

		/** abserr is L_\infty norm |e|, and relerr is |e|/|v| */
		ERROR_LINF
	}

	public static double errMax(final EstErr[] ee) {
		double errmax = 0.0;
		for (EstErr e : ee)
			if (e.err > errmax)
				errmax = e.err;
		return errmax;
	}

	public static class HyperCube {
		public int dim;
		public double[] center;
		public double[] halfwidth;

		/** cache volume = product of widths */
		public double vol;

		public void initFromCenterAndHalfwidth(final int dim, final double[] center, final double[] halfwidth) {
			this.dim = dim;
			this.center = center.clone();
			this.halfwidth = halfwidth.clone();
			compute_vol();
		}

		public void initFromRange(final int dim, final double[] xmin, final double[] xmax) {
			this.dim = dim;
			center = new double[dim];
			halfwidth = new double[dim];
			for (int i = 0; i < dim; ++i) {
				center[i] = 0.5 * (xmin[i] + xmax[i]);
				halfwidth[i] = 0.5 * (xmax[i] - xmin[i]);
			}
			compute_vol();
		}

		public void compute_vol() {
			vol = 1.0;
			for (int i = 0; i < dim; ++i)
				vol *= 2 * halfwidth[i];
		}

		public HyperCube clone() {
			HyperCube ret = new HyperCube();
			ret.initFromCenterAndHalfwidth(dim, center, halfwidth);
			return ret;
		}
	}

	public static class Region {
		public HyperCube h;
		public int splitDim;

		/** dimensionality of vector integrand */
		public int fdim;

		/** array of length fdim */
		public EstErr[] ee;

		/** max ee[k].err */
		public double errmax;

		public void init(final HyperCube h, int fdim) {
			this.h = h.clone();
			splitDim = 0;
			this.fdim = fdim;
			if (h.center != null && h.halfwidth != null) {
				ee = new EstErr[fdim];
				for (int i = 0; i < fdim; ++i) {
					ee[i] = new EstErr();
				}
			}
		}

		public Region clone() {
			Region ret = new Region();
			ret.h = h.clone();
			ret.splitDim = splitDim;
			ret.fdim = fdim;
			if (ee != null) {
				ret.ee = new EstErr[ee.length];
				for (int i = 0; i < ee.length; ++i) {
					ret.ee[i] = new EstErr();
					ret.ee[i].val = ee[i].val;
					ret.ee[i].err = ee[i].err;
				}
			}
			ret.errmax = errmax;
			return ret;
		}

	}

	/**
	 * R2 should have been generated by Region R2 = R.clone() immediately after the
	 * call to this method
	 * 
	 * @param R
	 * @param R2
	 */
	public static void cutRegion(Region R, Region R2) {
		int d = R.splitDim, dim = R.h.dim;

		/** halfwidth in dimension d is split into two ... */
		R.h.halfwidth[d] *= 0.5;

		/** which leads to halving the volume of that hypercube */
		R.h.vol *= 0.5;

		/** copy updated hypercubes */
		R2.h.initFromCenterAndHalfwidth(dim, R.h.center, R.h.halfwidth);

		/** move center in dimension d to first half of splitted region */
		R.h.center[d] -= R.h.halfwidth[d];

		/** move center in dimension d to second half of splitted region */
		R2.h.center[d] += R.h.halfwidth[d];
	}

	public static class Rule {

		/** the dimensionality of the parameter space */
		public int dim;

		/** number of functions */
		public int fdim;

		/** number of evaluation points */
		public int num_points;

		/** max number of regions evaluated at once */
		public int num_regions;

		/** points to eval: num_regions * num_points * dim */
		public double[] pts;

		/** num_regions * num_points * fdim */
		public double[] vals;

		EvalError_func evalError;
	}

	public static interface EvalError_func {
		public int evalError_func(Rule r, int fdim, Integrand_v f, Object fdata, int nR, Region[] R);
	}

	/* Based on orbitrule.cpp in HIntLib-0.0.10 */
	/*
	 * ls0 returns the least-significant 0 bit of n (e.g. it returns 0 if the LSB is
	 * 0, it returns 1 if the 2 LSBs are 01, etc.).
	 */
	public static int ls0(int n) {
		final byte[] bits = { 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1,
				0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0,
				1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2,
				0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0,
				3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1,
				0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
				1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4,
				0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 8, };
		int bit = 0;
		while ((n & 0xff) == 0xff) {
			n >>= 8;
				bit += 8;
		}
		return bit + bits[n & 0xff];
	}

	/**
	 * Evaluate the integration points for all 2^n points (+/-r,...+/-r)
	 *
	 * A Gray-code ordering is used to minimize the number of coordinate updates in
	 * p, although this doesn't matter as much now that we are saving all pts.
	 */
	public static void evalR_Rfs(double[] pts, int dim, double[] p, final double[] c, final double[] r) {
		int i;

		/** 0/1 bit = +/- for corresponding element of r[] */
		int signs = 0; 

		/**
		 * We start with the point where r is ADDed in every coordinate (this implies
		 * signs=0).
		 */
		for (i = 0; i < dim; ++i)
			p[i] = c[i] + r[i];

		/** Loop through the points in Gray-code ordering */
		for (i = 0;; ++i) {
			int mask, d;

			System.arraycopy(p, 0, pts, 0, dim);
			// pts += dim; offset: dim

			/** which coordinate to flip */
			d = ls0(i); 
			if (d >= dim)
				break;

			/** flip the d-th bit and add/subtract r[d] */
			mask = 1 << d;
			signs ^= mask;
			p[d] = (signs & mask) == 1 ? c[d] - r[d] : c[d] + r[d];
		}
	}

	public static void evalRR0_0fs(double[] pts, int dim, double[] p, final double[] c, final double[] r) {
		int i, j;

		for (i = 0; i < dim - 1; ++i) {
			p[i] = c[i] - r[i];
			for (j = i + 1; j < dim; ++j) {
				p[j] = c[j] - r[j];
				System.arraycopy(p, 0, pts, 0, dim);
				// memcpy(pts, p, sizeof(double) * dim);
				// pts += dim;
				p[i] = c[i] + r[i];
				System.arraycopy(p, 0, pts, dim, dim);
				// memcpy(pts, p, sizeof(double) * dim);
				// pts += dim;
				p[j] = c[j] + r[j];
				System.arraycopy(p, 0, pts, 2 * dim, dim);
				// memcpy(pts, p, sizeof(double) * dim);
				// pts += dim;
				p[i] = c[i] - r[i];
				System.arraycopy(p, 0, pts, 3 * dim, dim);
				// memcpy(pts, p, sizeof(double) * dim);
				// pts += dim;

				p[j] = c[j]; /* Done with j -> Restore p[j] */
			}
			p[i] = c[i]; /* Done with i -> Restore p[i] */
		}
	}

	public static void evalR0_0fs4d(double[] pts, int dim, double[] p, final double[] c, final double[] r1,
			final double[] r2) {
		int i;

		System.arraycopy(p, 0, pts, 0, dim);
		// memcpy(pts, p, sizeof(double) * dim);
		// pts += dim;

		for (i = 0; i < dim; i++) {
			p[i] = c[i] - r1[i];
			System.arraycopy(p, 0, pts, dim, dim);
			// memcpy(pts, p, sizeof(double) * dim);
			// pts += dim;

			p[i] = c[i] + r1[i];
			System.arraycopy(p, 0, pts, 2 * dim, dim);
			// memcpy(pts, p, sizeof(double) * dim);
			// pts += dim;

			p[i] = c[i] - r2[i];
			System.arraycopy(p, 0, pts, 3 * dim, dim);
			// memcpy(pts, p, sizeof(double) * dim);
			// pts += dim;

			p[i] = c[i] + r2[i];
			System.arraycopy(p, 0, pts, 4 * dim, dim);
			// memcpy(pts, p, sizeof(double) * dim);
			// pts += dim;

			p[i] = c[i];
		}
	}


	public static class Rule75GenzMalik extends Rule {

		/* temporary arrays of length dim */
		double[] widthLambda, widthLambda2, p;

		/* dimension-dependent constants */
		double weight1, weight3, weight5;
		double weightE1, weightE3;
	}



//	public static int evalError_func(Rule75GenzMalik r, int fdim, Integrand_v f, Object fdata, int nR, Region[] R) {
//		/* lambda2 = sqrt(9/70), lambda4 = sqrt(9/10), lambda5 = sqrt(9/19) */
//		final double lambda2 = 0.3585685828003180919906451539079374954541;
//		final double lambda4 = 0.9486832980505137995996680633298155601160;
//		final double lambda5 = 0.6882472016116852977216287342936235251269;
//		final double weight2 = 980. / 6561.;
//		final double weight4 = 200. / 19683.;
//		final double weightE2 = 245. / 486.;
//		final double weightE4 = 25. / 729.;
//		final double ratio = (lambda2 * lambda2) / (lambda4 * lambda4);
//
//		int i, j, iR, dim = r.dim;
//		int npts = 0;
//		double[] diff, pts, vals;
//
////		if (alloc_rule_pts(r_, nR))
////			return FAILURE;
//		pts = r.pts;
//		vals = r.vals;
//
//		for (iR = 0; iR < nR; ++iR) {
//			final double[] center = R[iR].h.center;
//			final double[] halfwidth = R[iR].h.halfwidth;
//
//			for (i = 0; i < dim; ++i)
//				r.p[i] = center[i];
//
//				for (i = 0; i < dim; ++i)
//					r.widthLambda2[i] = halfwidth[i] * lambda2;
//					for (i = 0; i < dim; ++i)
//						r.widthLambda[i] = halfwidth[i] * lambda4;
//
//						/* Evaluate points in the center, in (lambda2,0,...,0) and
//		 (lambda3=lambda4, 0,...,0).  */
//						evalR0_0fs4d(pts + npts * dim, dim, r.p, center, r.widthLambda2,
//								r.widthLambda);
//						npts += num0_0(dim) + 2 * numR0_0fs(dim);
//
//						/* Calculate points for (lambda4, lambda4, 0, ...,0) */
//						evalRR0_0fs(pts + npts * dim, dim, r->p, center, r->widthLambda);
//						npts += numRR0_0fs(dim);
//
//						/* Calculate points for (lambda5, lambda5, ..., lambda5) */
//						for (i = 0; i < dim; ++i)
//							r->widthLambda[i] = halfwidth[i] * lambda5;
//							evalR_Rfs(pts + npts * dim, dim, r->p, center, r->widthLambda);
//							npts += numR_Rfs(dim);
//		}
//
//		/* Evaluate the integrand function(s) at all the points */
//		if (f(dim, npts, pts, fdata, fdim, vals))
//			return FAILURE;
//
//		/* we are done with the points, and so we can re-use the pts
//	 array to store the maximum difference diff[i] in each dimension
//	 for each hypercube */
//		diff = pts;
//		for (i = 0; i < dim * nR; ++i)
//			diff[i] = 0;
//
//		for (j = 0; j < fdim; ++j) {
//			const double *v = vals + j;
//			#         define VALS(i) v[fdim*(i)]	       
//					for (iR = 0; iR < nR; ++iR) {
//						double result, res5th;
//						double val0, sum2 = 0, sum3 = 0, sum4 = 0, sum5 = 0;
//						unsigned k, k0 = 0;
//						/* accumulate j-th function values into j-th integrals
//			 NOTE: this relies on the ordering of the eval functions
//			 above, as well as on the internal structure of
//			 the evalR0_0fs4d function */
//
//						val0 = VALS(0); /* central point */
//						k0 += 1;
//
//						for (k = 0; k < dim; ++k) {
//							double v0 = VALS(k0 + 4 * k);
//							double v1 = VALS((k0 + 4 * k) + 1);
//							double v2 = VALS((k0 + 4 * k) + 2);
//							double v3 = VALS((k0 + 4 * k) + 3);
//
//							sum2 += v0 + v1;
//							sum3 += v2 + v3;
//
//							diff[iR * dim + k] += fabs(
//									v0 + v1 - 2 * val0 - ratio * (v2 + v3 - 2 * val0));
//						}
//						k0 += 4 * k;
//
//						for (k = 0; k < numRR0_0fs(dim); ++k)
//							sum4 += VALS(k0 + k);
//						k0 += k;
//
//						for (k = 0; k < numR_Rfs(dim); ++k)
//							sum5 += VALS(k0 + k);
//
//						/* Calculate fifth and seventh order results */
//						result = R[iR].h.vol
//								* (r->weight1 * val0 + weight2 * sum2 + r->weight3 * sum3
//										+ weight4 * sum4 + r->weight5 * sum5);
//						res5th = R[iR].h.vol
//								* (r->weightE1 * val0 + weightE2 * sum2 + r->weightE3 * sum3
//										+ weightE4 * sum4);
//
//						R[iR].ee[j].val = result;
//						R[iR].ee[j].err = fabs(res5th - result);
//
//						v += r_->num_points * fdim;
//					}
//			#         undef VALS
//		}
//
//		/* figure out dimension to split: */
//		for (iR = 0; iR < nR; ++iR) {
//			double maxdiff = 0;
//			unsigned dimDiffMax = 0;
//
//			for (i = 0; i < dim; ++i)
//				if (diff[iR * dim + i] > maxdiff) {
//					maxdiff = diff[iR * dim + i];
//					dimDiffMax = i;
//				}
//			R[iR].splitDim = dimDiffMax;
//		}
//
//
//		return SUCCESS;
//	}
//








}
